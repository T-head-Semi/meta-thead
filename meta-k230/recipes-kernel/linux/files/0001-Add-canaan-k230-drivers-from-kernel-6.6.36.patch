From f6bcb4069996a21bee268ed171b6bee21bd29f74 Mon Sep 17 00:00:00 2001
From: "yangtianyu.lu" <luyangtianyu.lyty@alibaba-inc.com>
Date: Tue, 10 Sep 2024 03:07:17 +0000
Subject: [PATCH] Add canaan-k230 drivers from kernel 6.6.36

---
 drivers/misc/Kconfig                 |   1 +
 drivers/misc/Makefile                |   1 +
 drivers/misc/canaan/Kconfig          |   7 +
 drivers/misc/canaan/Makefile         |   3 +
 drivers/misc/canaan/ai2d/Kconfig     |   8 +
 drivers/misc/canaan/ai2d/Makefile    |   2 +
 drivers/misc/canaan/ai2d/k230_ai2d.c | 261 +++++++++++++++++
 drivers/misc/canaan/gnne/Kconfig     |   8 +
 drivers/misc/canaan/gnne/Makefile    |   2 +
 drivers/misc/canaan/gnne/k230_gnne.c | 303 ++++++++++++++++++++
 drivers/misc/canaan/mmz/Kconfig      |   8 +
 drivers/misc/canaan/mmz/Makefile     |   2 +
 drivers/misc/canaan/mmz/mmz.c        | 303 ++++++++++++++++++++
 drivers/reset/Kconfig                |  11 +
 drivers/reset/Makefile               |   1 +
 drivers/reset/reset-k230.c           | 401 +++++++++++++++++++++++++++
 16 files changed, 1322 insertions(+)
 create mode 100644 drivers/misc/canaan/Kconfig
 create mode 100644 drivers/misc/canaan/Makefile
 create mode 100644 drivers/misc/canaan/ai2d/Kconfig
 create mode 100644 drivers/misc/canaan/ai2d/Makefile
 create mode 100644 drivers/misc/canaan/ai2d/k230_ai2d.c
 create mode 100644 drivers/misc/canaan/gnne/Kconfig
 create mode 100644 drivers/misc/canaan/gnne/Makefile
 create mode 100644 drivers/misc/canaan/gnne/k230_gnne.c
 create mode 100644 drivers/misc/canaan/mmz/Kconfig
 create mode 100644 drivers/misc/canaan/mmz/Makefile
 create mode 100644 drivers/misc/canaan/mmz/mmz.c
 create mode 100644 drivers/reset/reset-k230.c

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index cadd4a820c03..a52b7143c505 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -579,4 +579,5 @@ source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/uacce/Kconfig"
 source "drivers/misc/pvpanic/Kconfig"
 source "drivers/misc/mchp_pci1xxxx/Kconfig"
+source "drivers/misc/canaan/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index f2a4d1ff65d4..8813a5272b63 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -67,3 +67,4 @@ obj-$(CONFIG_TMR_MANAGER)      += xilinx_tmr_manager.o
 obj-$(CONFIG_TMR_INJECT)	+= xilinx_tmr_inject.o
 obj-$(CONFIG_TPS6594_ESM)	+= tps6594-esm.o
 obj-$(CONFIG_TPS6594_PFSM)	+= tps6594-pfsm.o
+obj-y						+= canaan/
diff --git a/drivers/misc/canaan/Kconfig b/drivers/misc/canaan/Kconfig
new file mode 100644
index 000000000000..dadfa91632b4
--- /dev/null
+++ b/drivers/misc/canaan/Kconfig
@@ -0,0 +1,7 @@
+menu "Canaan k230 drivers"
+
+source "drivers/misc/canaan/gnne/Kconfig"
+source "drivers/misc/canaan/ai2d/Kconfig"
+source "drivers/misc/canaan/mmz/Kconfig"
+
+endmenu
diff --git a/drivers/misc/canaan/Makefile b/drivers/misc/canaan/Makefile
new file mode 100644
index 000000000000..2bf8beb7c021
--- /dev/null
+++ b/drivers/misc/canaan/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_K230_GNNE_DRIVER) += gnne/
+obj-$(CONFIG_K230_GNNE_DRIVER) += ai2d/
+obj-$(CONFIG_K230_MMZ) += mmz/
diff --git a/drivers/misc/canaan/ai2d/Kconfig b/drivers/misc/canaan/ai2d/Kconfig
new file mode 100644
index 000000000000..7c595197f041
--- /dev/null
+++ b/drivers/misc/canaan/ai2d/Kconfig
@@ -0,0 +1,8 @@
+config K230_AI2D_DRIVER
+		tristate "K230 AI2D driver"
+		default	m
+		help
+		This option enables support for K230
+		Say Y for enabling the k230 ai2d driver
+		To compile this support as a module, choose M here
+		If unsure, say N.
\ No newline at end of file
diff --git a/drivers/misc/canaan/ai2d/Makefile b/drivers/misc/canaan/ai2d/Makefile
new file mode 100644
index 000000000000..5ec1a2070b95
--- /dev/null
+++ b/drivers/misc/canaan/ai2d/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_K230_AI2D_DRIVER)      = k230_ai2d.o
\ No newline at end of file
diff --git a/drivers/misc/canaan/ai2d/k230_ai2d.c b/drivers/misc/canaan/ai2d/k230_ai2d.c
new file mode 100644
index 000000000000..122dc153916d
--- /dev/null
+++ b/drivers/misc/canaan/ai2d/k230_ai2d.c
@@ -0,0 +1,261 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/cdev.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/kfifo.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/irqflags.h>
+#include <linux/module.h>
+#include <linux/cpu.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/cacheinfo.h>
+#include <linux/sizes.h>
+#include <asm/csr.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+
+struct ai2d_plat {
+	struct resource *res;
+	void __iomem *regs;
+	char *ai2d_reg;
+	int major;
+	int minor;
+	int irq;
+	struct class *class;
+	struct device *device;
+	struct cdev cdev;
+};
+
+static struct ai2d_plat *plat;
+static unsigned int ai2d_int_flag;
+static int ai2d_fasync_flag;
+DECLARE_WAIT_QUEUE_HEAD(ai2d_waitq);
+struct fasync_struct *ai2d_fasync;
+
+static DEFINE_MUTEX(ai2d_mutex);
+
+static void ai2d_interrupt_clear(void)
+{
+	iowrite32(0x1, (plat->ai2d_reg + 0xa0));
+	iowrite32(0x0, (plat->ai2d_reg + 0xa4));
+	iowrite32(0x0, (plat->ai2d_reg + 0xa8));
+	iowrite32(0x0, (plat->ai2d_reg + 0xac));
+}
+
+static irqreturn_t ai2d_irq(int irq, void *dev_id)
+{
+	ai2d_interrupt_clear();
+	ai2d_int_flag = 1;
+	wake_up_interruptible(&ai2d_waitq);
+
+	if (ai2d_fasync_flag)
+		kill_fasync(&ai2d_fasync, SIGIO, POLL_IN);
+	return IRQ_HANDLED;
+}
+
+static int ai2d_drv_fasync(int fd, struct file *file, int on)
+{
+	int err;
+
+	err = fasync_helper(fd, file, on, &ai2d_fasync);
+	if (err < 0)
+		return err;
+
+	ai2d_fasync_flag = on;
+
+	return 0;
+}
+
+static unsigned int ai2d_poll(struct file *file, poll_table *wait)
+{
+	unsigned int ret = 0;
+
+	poll_wait(file, &ai2d_waitq, wait);
+	if (ai2d_int_flag) {
+		ret |= POLLIN;
+		ai2d_int_flag = 0;
+	}
+
+	return ret;
+}
+
+static int ai2d_open(struct inode *inode, struct file *filp)
+{
+	ai2d_int_flag = 0;
+	return 0;
+}
+
+static int ai2d_release(struct inode *inode, struct file *filp)
+{
+	ai2d_int_flag = 0;
+	return 0;
+}
+
+const struct file_operations ai2d_fops = {
+	.owner = THIS_MODULE,
+	.open = ai2d_open,
+	.release = ai2d_release,
+	.poll = ai2d_poll,
+	.fasync = ai2d_drv_fasync,
+};
+
+static int ai2d_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int err = 0;
+	dev_t dev = 0;
+	int devno;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		pr_err("%s: get resource failed\n", __func__);
+		err = -ENODEV;
+		goto error;
+	}
+
+	plat = kzalloc(sizeof(struct ai2d_plat), GFP_KERNEL);
+	if (!plat) {
+		err = -ENOMEM;
+		goto error;
+	}
+
+	plat->res = res;
+
+	plat->irq = platform_get_irq(pdev, 0);
+	if (plat->irq < 0) {
+		pr_err("Gnne get irq err\n");
+		err = -ENODEV;
+		goto cleanup_kmem;
+	}
+
+	err = request_irq(plat->irq, ai2d_irq, 0, "t0", NULL);
+	if (err) {
+		pr_err("Gnne request irq err %d\n", err);
+		goto cleanup_kmem;
+	}
+
+	plat->regs = ioremap(res->start, resource_size(res));
+	if (!plat->regs) {
+		pr_err("could not remap register memory\n");
+		err = -ENOMEM;
+		goto cleanup_irq;
+	}
+	plat->ai2d_reg = plat->regs;
+
+	plat->major = 0;
+	plat->minor = 0;
+
+	err = alloc_chrdev_region(&dev, 0, 1, "k230-ai2d");
+	if (err) {
+		pr_err("k230-ai2d: can't get major %d\n",
+			plat->major);
+		goto cleanup_ioremap;
+	}
+	plat->major = MAJOR(dev);
+
+	plat->class = class_create("k230_ai2d_class");
+	if (IS_ERR(plat->class)) {
+		err = PTR_ERR(plat->class);
+		goto cleanup_ioremap;
+	}
+
+	devno = MKDEV(plat->major, plat->minor);
+
+	cdev_init(&plat->cdev, &ai2d_fops);
+	plat->cdev.owner = THIS_MODULE;
+	err = cdev_add(&plat->cdev, devno, 1);
+	if (err) {
+		pr_err("Error %d adding ai2d device number %d\n", err, plat->minor);
+		goto cleanup_class;
+	}
+
+	plat->device =
+		device_create(plat->class, NULL, devno, NULL, "k230-ai2d");
+	if (IS_ERR(plat->device)) {
+		pr_err("device not created\n");
+		err = PTR_ERR(plat->device);
+		goto cleanup_cdev;
+	}
+
+	return 0;
+
+cleanup_cdev:
+	cdev_del(&plat->cdev);
+cleanup_class:
+	class_destroy(plat->class);
+cleanup_ioremap:
+	iounmap(plat->regs);
+cleanup_irq:
+	free_irq(plat->irq, NULL);
+cleanup_kmem:
+	kfree(plat);
+error:
+	return err;
+}
+
+static int ai2d_remove(struct platform_device *pdev)
+{
+	dev_t dev = MKDEV(plat->major, plat->minor);
+
+	device_destroy(plat->class, dev);
+	cdev_del(&plat->cdev);
+	class_destroy(plat->class);
+	iounmap(plat->regs);
+	free_irq(plat->irq, NULL);
+	kfree(plat);
+
+	return 0;
+}
+
+static const struct of_device_id k230_ai2d_ids[] = { { .compatible =
+							       "k230-ai2d" },
+						     {} };
+
+static struct platform_driver k230_ai2d_driver = {
+	.probe          = ai2d_probe,
+	.remove         = ai2d_remove,
+	.driver         = {
+		.name           = "k230-ai2d",
+		.of_match_table = of_match_ptr(k230_ai2d_ids),
+	},
+};
+
+int ai2d_module_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&k230_ai2d_driver);
+
+	return ret;
+}
+
+void ai2d_module_deinit(void)
+{
+	platform_driver_unregister(&k230_ai2d_driver);
+}
+
+module_init(ai2d_module_init);
+module_exit(ai2d_module_deinit);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Driver for k230 ai2d");
diff --git a/drivers/misc/canaan/gnne/Kconfig b/drivers/misc/canaan/gnne/Kconfig
new file mode 100644
index 000000000000..284738d43088
--- /dev/null
+++ b/drivers/misc/canaan/gnne/Kconfig
@@ -0,0 +1,8 @@
+config K230_GNNE_DRIVER
+		tristate "K230 GNNE driver"
+		default m
+		help
+		This option enables support for K230
+		Say Y for enabling the k230 gnne driver
+		To compile this support as a module, choose M here
+		If unsure, say N.
\ No newline at end of file
diff --git a/drivers/misc/canaan/gnne/Makefile b/drivers/misc/canaan/gnne/Makefile
new file mode 100644
index 000000000000..1e7f5c271920
--- /dev/null
+++ b/drivers/misc/canaan/gnne/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_K230_GNNE_DRIVER)      = k230_gnne.o
diff --git a/drivers/misc/canaan/gnne/k230_gnne.c b/drivers/misc/canaan/gnne/k230_gnne.c
new file mode 100644
index 000000000000..357369e3685c
--- /dev/null
+++ b/drivers/misc/canaan/gnne/k230_gnne.c
@@ -0,0 +1,303 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/cdev.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/kfifo.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/irqflags.h>
+#include <linux/module.h>
+#include <linux/cpu.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/cacheinfo.h>
+#include <linux/sizes.h>
+#include <asm/csr.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/dma-mapping.h>
+
+#define gnne_writeq(v, addr)                       \
+	{                                         \
+		(*(uint64_t *)((size_t)(addr))) = (v); \
+	}
+
+struct gnne_plat {
+	struct resource *res;
+	void __iomem *regs;
+	char *gnne_reg;
+	int major;
+	int minor;
+	int irq;
+	struct class *class;
+	struct device *device;
+	struct cdev cdev;
+};
+
+static struct gnne_plat *plat;
+static unsigned int gnne_int_flag;
+static int gnne_fasync_flag;
+DECLARE_WAIT_QUEUE_HEAD(gnne_waitq);
+struct fasync_struct *gnne_fasync;
+
+static DEFINE_MUTEX(gnne_mutex);
+
+static void gnne_interrupt_clear(void)
+{
+	gnne_writeq(0x400000004, (plat->gnne_reg + 0x128));
+}
+
+static irqreturn_t gnne_irq(int irq, void *dev_id)
+{
+	gnne_interrupt_clear();
+	gnne_int_flag = 1;
+	wake_up_interruptible(&gnne_waitq);
+
+	if (gnne_fasync_flag)
+		kill_fasync(&gnne_fasync, SIGIO, POLL_IN);
+	return IRQ_HANDLED;
+}
+
+static int gnne_drv_fasync(int fd, struct file *file, int on)
+{
+	int err;
+
+	err = fasync_helper(fd, file, on, &gnne_fasync);
+	if (err < 0)
+		return err;
+
+	gnne_fasync_flag = on;
+
+	return 0;
+}
+
+static unsigned int gnne_poll(struct file *file, poll_table *wait)
+{
+	unsigned int ret = 0;
+
+	poll_wait(file, &gnne_waitq, wait);
+	if (gnne_int_flag) {
+		ret |= POLLIN;
+		gnne_int_flag = 0;
+	}
+
+	return ret;
+}
+
+static int gnne_open(struct inode *inode, struct file *filp)
+{
+	void __iomem *sysctl_reg;
+
+	gnne_int_flag = 0;
+
+	sysctl_reg = ioremap(0x91103028, 4);
+	if (!sysctl_reg) {
+		pr_err("can't remap gnne sysctl 0x%08X\n", 0x91103028);
+		return -1;
+	}
+	iowrite32(0x00030002, sysctl_reg);
+	iounmap(sysctl_reg);
+
+	sysctl_reg = ioremap(0x91100008, 4);
+	if (!sysctl_reg) {
+		pr_err("can't remap gnne sysctl 0x%08X\n", 0x91100008);
+		return -1;
+	}
+	iowrite32(0x80000405, sysctl_reg);
+	iowrite32(0x80000405, sysctl_reg);
+	iounmap(sysctl_reg);
+
+	return 0;
+}
+
+static int gnne_release(struct inode *inode, struct file *filp)
+{
+	void __iomem *sysctl_reg;
+
+	gnne_int_flag = 0;
+
+	sysctl_reg = ioremap(0x91103028, 4);
+	if (!sysctl_reg) {
+		pr_err("can't remap gnne sysctl 0x%08X\n", 0x91103028);
+		return -1;
+	}
+	iowrite32(0x00030001, sysctl_reg);
+	iounmap(sysctl_reg);
+
+	sysctl_reg = ioremap(0x91100008, 4);
+	if (!sysctl_reg) {
+		pr_err("can't remap gnne sysctl 0x%08X\n", 0x91100008);
+		return -1;
+	}
+	iowrite32(0x00000404, sysctl_reg);
+	iounmap(sysctl_reg);
+
+	return 0;
+}
+
+const struct file_operations gnne_fops = {
+	.owner = THIS_MODULE,
+	.open = gnne_open,
+	.release = gnne_release,
+	.poll = gnne_poll,
+	.fasync = gnne_drv_fasync,
+};
+
+static int gnne_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int err = 0;
+	dev_t dev = 0;
+
+	int devno;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		pr_err("%s: get resource failed", __func__);
+		err = -ENODEV;
+		goto error;
+	}
+
+	plat = kzalloc(sizeof(struct gnne_plat), GFP_KERNEL);
+	if (!plat) {
+		err = -ENOMEM;
+		goto error;
+	}
+
+	plat->res = res;
+
+	plat->irq = platform_get_irq(pdev, 0);
+	if (plat->irq < 0) {
+		pr_err("Gnne get irq err\n");
+		err = -ENODEV;
+		goto cleanup_kmem;
+	}
+
+	err = request_irq(plat->irq, gnne_irq, 0, "t0", NULL);
+	if (err) {
+		pr_err("Gnne request irq err %d\n", err);
+		goto cleanup_kmem;
+	}
+
+	plat->regs = ioremap(res->start, resource_size(res));
+	if (!plat->regs) {
+		pr_err("could not remap register memory\n");
+		err = -ENOMEM;
+		goto cleanup_irq;
+	}
+	plat->gnne_reg = plat->regs;
+
+	plat->major = 0;
+	plat->minor = 0;
+
+	err = alloc_chrdev_region(&dev, 0, 1, "k230-gnne");
+	if (err) {
+		pr_err("k230-gnne: can't get major %d\n",
+			plat->major);
+		goto cleanup_ioremap;
+	}
+	plat->major = MAJOR(dev);
+
+	plat->class = class_create("k230_gnne_class");
+	if (IS_ERR(plat->class)) {
+		err = PTR_ERR(plat->class);
+		goto cleanup_ioremap;
+	}
+
+	devno = MKDEV(plat->major, plat->minor);
+
+	cdev_init(&plat->cdev, &gnne_fops);
+	plat->cdev.owner = THIS_MODULE;
+	err = cdev_add(&plat->cdev, devno, 1);
+	if (err) {
+		pr_err("Error %d adding gnne device number %d\n", err, plat->minor);
+		goto cleanup_class;
+	}
+
+	plat->device =
+		device_create(plat->class, NULL, devno, NULL, "k230-gnne");
+	if (IS_ERR(plat->device)) {
+		pr_err("device not created\n");
+		err = PTR_ERR(plat->device);
+		goto cleanup_cdev;
+	}
+
+	return 0;
+
+cleanup_cdev:
+	cdev_del(&plat->cdev);
+cleanup_class:
+	class_destroy(plat->class);
+cleanup_ioremap:
+	iounmap(plat->regs);
+cleanup_irq:
+	free_irq(plat->irq, NULL);
+cleanup_kmem:
+	kfree(plat);
+error:
+	return err;
+}
+
+static int gnne_remove(struct platform_device *pdev)
+{
+	dev_t dev = MKDEV(plat->major, plat->minor);
+
+	device_destroy(plat->class, dev);
+	cdev_del(&plat->cdev);
+	class_destroy(plat->class);
+	iounmap(plat->regs);
+	free_irq(plat->irq, NULL);
+	kfree(plat);
+
+	return 0;
+}
+
+static const struct of_device_id k230_gnne_ids[] = { { .compatible =
+								   "k230-gnne" },
+							 {} };
+
+static struct platform_driver k230_gnne_driver = {
+	.probe          = gnne_probe,
+	.remove         = gnne_remove,
+	.driver         = {
+		.name           = "k230-gnne",
+		.of_match_table = of_match_ptr(k230_gnne_ids),
+	},
+};
+
+int gnne_module_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&k230_gnne_driver);
+	return ret;
+}
+
+void gnne_module_deinit(void)
+{
+	platform_driver_unregister(&k230_gnne_driver);
+}
+
+module_init(gnne_module_init);
+module_exit(gnne_module_deinit);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Driver for k230 gnne");
diff --git a/drivers/misc/canaan/mmz/Kconfig b/drivers/misc/canaan/mmz/Kconfig
new file mode 100644
index 000000000000..fc527a4b7f18
--- /dev/null
+++ b/drivers/misc/canaan/mmz/Kconfig
@@ -0,0 +1,8 @@
+config K230_MMZ
+	tristate "K230 mem zone driver"
+	default	m
+	help
+		This option enables support for K230
+		Say Y for enabling the k230 mmz driver
+		To compile this support as a module, choose M here
+		If unsure, say N.
\ No newline at end of file
diff --git a/drivers/misc/canaan/mmz/Makefile b/drivers/misc/canaan/mmz/Makefile
new file mode 100644
index 000000000000..ce386380b1c2
--- /dev/null
+++ b/drivers/misc/canaan/mmz/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_K230_MMZ)      = mmz.o
diff --git a/drivers/misc/canaan/mmz/mmz.c b/drivers/misc/canaan/mmz/mmz.c
new file mode 100644
index 000000000000..1d61a6f11015
--- /dev/null
+++ b/drivers/misc/canaan/mmz/mmz.c
@@ -0,0 +1,303 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mman.h>
+#include <linux/random.h>
+#include <linux/init.h>
+#include <linux/tty.h>
+#include <linux/capability.h>
+#include <linux/ptrace.h>
+#include <linux/device.h>
+#include <linux/highmem.h>
+#include <linux/backing-dev.h>
+#include <linux/shmem_fs.h>
+#include <linux/splice.h>
+#include <linux/pfn.h>
+#include <linux/export.h>
+#include <linux/io.h>
+#include <linux/uio.h>
+#include <linux/uaccess.h>
+#include <linux/security.h>
+
+static struct device *mmz_dev;
+static DEFINE_MUTEX(mmz_mutex);
+
+#define MMZ_ALLOC_MEM _IOWR('g', 1, unsigned long)
+#define MMZ_FREE_MEM _IOWR('g', 2, unsigned long)
+struct mmz_info {
+	void *user_virt_addr;
+	void *kernel_virt_addr;
+	unsigned long mmz_phys;
+	unsigned long length;
+};
+
+static long mmz_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct mmz_info t_mem_info;
+
+	switch (cmd) {
+	case MMZ_ALLOC_MEM:
+		if (copy_from_user(&t_mem_info, (void *)arg,
+				   sizeof(struct mmz_info)))
+			return -EFAULT;
+		t_mem_info.kernel_virt_addr = dma_alloc_coherent(
+			mmz_dev, t_mem_info.length,
+			(dma_addr_t *)(&(t_mem_info.mmz_phys)),
+			GFP_KERNEL | GFP_DMA);
+		if (copy_to_user((void *)arg, &t_mem_info, sizeof(struct mmz_info)))
+			return -EFAULT;
+		break;
+	case MMZ_FREE_MEM:
+		if (copy_from_user(&t_mem_info, (void *)arg,
+				   sizeof(struct mmz_info)))
+			return -EFAULT;
+		dma_free_coherent(mmz_dev, t_mem_info.length,
+				  t_mem_info.kernel_virt_addr,
+				  t_mem_info.mmz_phys);
+		break;
+	default:
+		pr_err("%s: Unknown ioctl: 0x%.8X\n", __func__, cmd);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static long mmz_unlocked_ioctl(struct file *file, unsigned int cmd,
+			       unsigned long arg)
+{
+	long ret = 0;
+
+	mutex_lock(&mmz_mutex);
+	ret = mmz_ioctl(file, cmd, arg);
+	mutex_unlock(&mmz_mutex);
+
+	return ret;
+}
+
+#ifndef ARCH_HAS_VALID_PHYS_ADDR_RANGE
+static inline int valid_phys_addr_range(phys_addr_t addr, size_t count)
+{
+	return addr + count <= __pa(high_memory);
+}
+
+static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)
+{
+	return 1;
+}
+#endif
+
+#ifndef CONFIG_MMU
+static unsigned long
+get_unmapped_area_mem(struct file *file, unsigned long addr, unsigned long len,
+		      unsigned long pgoff, unsigned long flags)
+{
+	if (!valid_mmap_phys_addr_range(pgoff, len))
+		return (unsigned long)-EINVAL;
+	return pgoff << PAGE_SHIFT;
+}
+
+/* permit direct mmap, for read, write or exec */
+static unsigned int memory_mmap_capabilities(struct file *file)
+{
+	return NOMMU_MAP_DIRECT | NOMMU_MAP_READ | NOMMU_MAP_WRITE |
+	       NOMMU_MAP_EXEC;
+}
+
+static unsigned int zero_mmap_capabilities(struct file *file)
+{
+	return NOMMU_MAP_COPY;
+}
+
+/* can't do an in-place private mapping if there's no MMU */
+static inline int private_mapping_ok(struct vm_area_struct *vma)
+{
+	return is_nommu_shared_mapping(vma->vm_flags);
+}
+#else
+
+static inline int private_mapping_ok(struct vm_area_struct *vma)
+{
+	return 1;
+}
+#endif
+
+#ifdef CONFIG_STRICT_DEVMEM
+static inline int page_is_allowed(unsigned long pfn)
+{
+	return devmem_is_allowed(pfn);
+}
+static inline int range_is_allowed(unsigned long pfn, unsigned long size)
+{
+	u64 from = ((u64)pfn) << PAGE_SHIFT;
+	u64 to = from + size;
+	u64 cursor = from;
+
+	while (cursor < to) {
+		if (!devmem_is_allowed(pfn))
+			return 0;
+		cursor += PAGE_SIZE;
+		pfn++;
+	}
+	return 1;
+}
+#else
+static inline int page_is_allowed(unsigned long pfn)
+{
+	return 1;
+}
+static inline int range_is_allowed(unsigned long pfn, unsigned long size)
+{
+	return 1;
+}
+#endif
+
+int __weak phys_mem_access_prot_allowed(struct file *file, unsigned long pfn,
+					unsigned long size, pgprot_t *vma_prot)
+{
+	return 1;
+}
+
+#ifdef pgprot_noncached
+static int uncached_access(struct file *file, phys_addr_t addr)
+{
+#if defined(CONFIG_IA64)
+	/*
+	 * On ia64, we ignore O_DSYNC because we cannot tolerate memory
+	 * attribute aliases.
+	 */
+	return !(efi_mem_attributes(addr) & EFI_MEMORY_WB);
+#else
+	/*
+	 * Accessing memory above the top the kernel knows about or through a
+	 * file pointer
+	 * that was marked O_DSYNC will be done non-cached.
+	 */
+	if (file->f_flags & O_DSYNC)
+		return 1;
+	return addr >= __pa(high_memory);
+#endif
+}
+#endif
+
+static pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+				     unsigned long size, pgprot_t vma_prot)
+{
+#ifdef pgprot_noncached
+	phys_addr_t offset = pfn << PAGE_SHIFT;
+
+	if (uncached_access(file, offset))
+		return pgprot_noncached(vma_prot);
+#endif
+	return vma_prot;
+}
+
+static const struct vm_operations_struct mmap_mem_ops = {
+#ifdef CONFIG_HAVE_IOREMAP_PROT
+	.access = generic_access_phys
+#endif
+};
+
+static int mmz_map(struct file *file, struct vm_area_struct *vma)
+{
+	size_t size = vma->vm_end - vma->vm_start;
+	phys_addr_t offset = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT;
+
+	/* Does it even fit in phys_addr_t? */
+	if (offset >> PAGE_SHIFT != vma->vm_pgoff)
+		return -EINVAL;
+
+	/* It's illegal to wrap around the end of the physical address space. */
+	if (offset + (phys_addr_t)size - 1 < offset)
+		return -EINVAL;
+
+	if (!valid_mmap_phys_addr_range(vma->vm_pgoff, size))
+		return -EINVAL;
+
+	if (!private_mapping_ok(vma))
+		return -EINVAL;
+
+	if (!range_is_allowed(vma->vm_pgoff, size))
+		return -EPERM;
+
+	if (!phys_mem_access_prot_allowed(file, vma->vm_pgoff, size,
+					  &vma->vm_page_prot))
+		return -EINVAL;
+
+	if (offset < 0x80000000)
+		vma->vm_page_prot.pgprot &= ~(1ULL << 63);
+	else {
+		vma->vm_page_prot = phys_mem_access_prot(
+			file, vma->vm_pgoff, size, vma->vm_page_prot);
+	}
+
+	vma->vm_ops = &mmap_mem_ops;
+
+	/* Remap-pfn-range will mark the range VM_IO */
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, size,
+			    vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int mmap_mem(struct file *file, struct vm_area_struct *vma)
+{
+	int ret = 0;
+
+	mutex_lock(&mmz_mutex);
+	mmz_map(file, vma);
+	mutex_unlock(&mmz_mutex);
+
+	return ret;
+}
+
+static const struct file_operations mmz_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = mmz_unlocked_ioctl,
+	.mmap = mmap_mem,
+};
+
+static struct miscdevice mmz_misc = {
+	.name = "mmz",
+	.fops = &mmz_fops,
+};
+
+static int __init mmz_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&mmz_misc);
+	if (unlikely(ret)) {
+		pr_err("failed to register mmz test misc device!\n");
+		return ret;
+	}
+	mmz_dev = mmz_misc.this_device;
+	mmz_dev->coherent_dma_mask = ~0;
+	_dev_info(mmz_dev, "registered.\n");
+
+	return ret;
+}
+module_init(mmz_init);
+
+static void __exit mmz_exit(void)
+{
+	misc_deregister(&mmz_misc);
+}
+module_exit(mmz_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Driver for alloc continuous memory for user");
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index 9273d1e6fe80..7461ffbe40be 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -102,6 +102,17 @@ config RESET_K210
 	  Say Y if you want to control reset signals provided by this
 	  controller.
 
+config RESET_K230
+	bool "Reset controller driver for Canaan Kendryte K230 SoC"
+	depends on RISCV && OF && ARCH_CANAAN
+	select MFD_SYSCON
+	default ARCH_CANAAN
+	help
+	  Support for the Canaan Kendryte K230 RISC-V SoC reset controller.
+	  Say Y if you want to control reset signals
+	  provided by this
+	  controller.
+
 config RESET_LANTIQ
 	bool "Lantiq XWAY Reset Driver" if COMPILE_TEST
 	default SOC_TYPE_XWAY
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index 5c858e62241a..e00ff19d4c42 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_RESET_HSDK) += reset-hsdk.o
 obj-$(CONFIG_RESET_IMX7) += reset-imx7.o
 obj-$(CONFIG_RESET_INTEL_GW) += reset-intel-gw.o
 obj-$(CONFIG_RESET_K210) += reset-k210.o
+obj-$(CONFIG_RESET_K230) += reset-k230.o
 obj-$(CONFIG_RESET_LANTIQ) += reset-lantiq.o
 obj-$(CONFIG_RESET_LPC18XX) += reset-lpc18xx.o
 obj-$(CONFIG_RESET_MCHP_SPARX5) += reset-microchip-sparx5.o
diff --git a/drivers/reset/reset-k230.c b/drivers/reset/reset-k230.c
new file mode 100644
index 000000000000..41c8e8941da0
--- /dev/null
+++ b/drivers/reset/reset-k230.c
@@ -0,0 +1,401 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/****************************************************
+ * 1. 写provider.dtsi，组织reset模块的形式（标准格式：phandle+specifier），
+ *     使得扫描device tree后生成的id格式统一
+ * 2. 在dt-bindings目录下写头文件，将所有的模块按照一定的格式描述出来
+ * 3. 编写驱动文件，按照不同的类型reset对应的模块。
+ *
+ * id的格式：根据reset_consumer.dtsi中定义的格式类型，即
+ *      _________________
+ *      | phandle | offset | type | done | assert |
+ *      —————————————————
+ * 经过xlate函数翻译之后，将reset属性翻译成id，其中id的形式如下：
+ *      31     16|15  14|13   7|6      0
+ *      ——————————————————
+ *      | offset | type | done | reset |
+ *      ————————————————————
+ * id最终将提供给reset_control_ops使用
+ */
+
+/*
+ * Copyright (c) 2016-2017 Linaro Ltd.
+ * Copyright (c) 2022, Canaan Bright Sight Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <dt-bindings/reset/canaan-k230-reset.h>
+#include <linux/reboot.h>
+
+#define K230_RESET_DEBUG
+
+struct k230_reset_controller {
+	spinlock_t lock;
+	void __iomem *membase;
+	struct reset_controller_dev rst;
+};
+
+#define to_k230_reset_controller(_rst) \
+	container_of(_rst, struct k230_reset_controller, rst)
+
+static int k230_reset_of_xlate(struct reset_controller_dev *rcdev,
+			       const struct of_phandle_args *reset_spec)
+{
+	u32 offset;
+	u32 type;
+	u32 done;
+	u32 reset;
+
+	offset = (reset_spec->args[0] << K230_RESET_REG_OFFSET_SHIFT) &
+		 K230_RESET_REG_OFFSET_MASK;
+	type = (reset_spec->args[1] << K230_RESET_TYPE_SHIFT) &
+	       K230_RESET_TYPE_MASK;
+	done = (reset_spec->args[2] << K230_RESET_DONE_BIT_SHIFT) &
+	       K230_RESET_DONE_BIT_MASK;
+	reset = (reset_spec->args[3] << K230_RESET_ASSERT_BIT_SHIFT) &
+		K230_RESET_ASSERT_BIT_MASK;
+
+	return (offset | type | done | reset);
+}
+
+static int k230_reset(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct k230_reset_controller *rstc = to_k230_reset_controller(rcdev);
+	unsigned long flags;
+	u32 offset = (id & K230_RESET_REG_OFFSET_MASK) >>
+		     K230_RESET_REG_OFFSET_SHIFT;
+	u32 type = (id & K230_RESET_TYPE_MASK) >> K230_RESET_TYPE_SHIFT;
+	u32 done = (id & K230_RESET_DONE_BIT_MASK) >> K230_RESET_DONE_BIT_SHIFT;
+	u32 reset = (id & K230_RESET_ASSERT_BIT_MASK) >>
+		    K230_RESET_ASSERT_BIT_SHIFT;
+	u32 reg;
+
+	spin_lock_irqsave(&rstc->lock, flags);
+	switch (type) {
+	case K230_RESET_TYPE_CPU: {
+		/* clear done bit */
+		reg = readl(rstc->membase + offset);
+		reg |= (1 << done);
+		reg |= (1 << (done + 0x10)); // note: write enable
+		writel(reg, rstc->membase + offset);
+
+		/* set reset bit */
+		reg |= (1 << reset);
+		reg |= (1 << (reset + 0x10)); // note: write enable
+		writel(reg, rstc->membase + offset);
+
+		udelay(10);
+
+		/* clear reset bit */
+		if (offset == 0xc) {
+			reg &= ~(1 << reset);
+			reg &= (1 << (reset + 0x10)); // note: write enable
+			writel(reg, rstc->membase + offset);
+		}
+
+		/* wait done bit set */
+		while (1) {
+			reg = readl(rstc->membase + offset);
+			if (reg & (1 << done)) {
+				/* clear done and break */
+				writel(reg, rstc->membase + offset);
+				break;
+			}
+		}
+		break;
+	}
+	case K230_RESET_TYPE_HW_AUTO_DONE: {
+		/* clear done bit */
+		reg = readl(rstc->membase + offset);
+		reg |= (1 << done);
+		writel(reg, rstc->membase + offset);
+
+		/* set reset bit */
+		reg = readl(rstc->membase + offset);
+
+		reg |= (1 << reset);
+		writel(reg, rstc->membase + offset);
+
+		/* wait done bit set */
+		while (1) {
+			reg = readl(rstc->membase + offset);
+			if (reg & (1 << done)) {
+				/* clear done and break */
+				writel(reg, rstc->membase + offset);
+				break;
+			}
+		}
+		break;
+	}
+	case K230_RESET_TYPE_SW_SET_DONE: {
+		/* set reset bit */
+		reg = readl(rstc->membase + offset);
+		if ((offset == 0x20) || (offset == 0x24) || (offset == 0x80) ||
+		    (offset == 0x64)) {
+			reg &= ~(1 << reset); //special，复位：reset=0
+		} else if ((offset == 0x4) || (offset == 0xc)) {
+			reg |= (1 << reset);
+			reg |= (1 << (reset + 0x10)); //note: write enable
+		} else {
+			reg |= (1 << reset);
+		}
+		writel(reg, rstc->membase + offset);
+
+		udelay(10);
+
+		/* clear reset bit */
+		if ((offset != 0x4) &&
+		    (offset != 0xc)) { //special，0x4, 0xc寄存器是自动清零
+			if (offset == 0xa8) {
+				reg &= ~(1 << reset);
+				writel(reg, rstc->membase + offset);
+			} else {
+				reg |= (1 << reset);
+				writel(reg, rstc->membase + offset);
+			}
+		}
+
+		break;
+	}
+	default: {
+		break;
+	}
+	}
+
+	spin_unlock_irqrestore(&rstc->lock, flags);
+	return 0;
+}
+
+static int k230_reset_assert(struct reset_controller_dev *rcdev,
+			     unsigned long id)
+{
+	struct k230_reset_controller *rstc = to_k230_reset_controller(rcdev);
+	unsigned long flags;
+	u32 offset = (id & K230_RESET_REG_OFFSET_MASK) >>
+		     K230_RESET_REG_OFFSET_SHIFT;
+	u32 type = (id & K230_RESET_TYPE_MASK) >> K230_RESET_TYPE_SHIFT;
+	/*u32 done    = (id & K230_RESET_DONE_BIT_MASK) >> K230_RESET_DONE_BIT_SHIFT;*/
+	u32 reset = (id & K230_RESET_ASSERT_BIT_MASK) >>
+		    K230_RESET_ASSERT_BIT_SHIFT;
+	u32 reg;
+
+	// if(type == K230_RESET_TYPE_HW_AUTO_DONE) {
+	//     pr_err("hardware auto done reset DOESNOT support reset assert!");
+	// } else {
+	//     spin_lock_irqsave(&rstc->lock, flags);
+	//     reg = readl(rstc->membase+offset);
+	//     /* set reset bit */
+	//     reg |= (1 << reset);
+	//     writel(reg, rstc->membase+offset);
+	//     spin_unlock_irqrestore(&rstc->lock, flags);
+	// }
+	if (type == K230_RESET_TYPE_HW_AUTO_DONE) {
+		pr_err("hardware auto done reset DOESNOT support reset assert!");
+	} else if (type == K230_RESET_TYPE_CPU) {
+		spin_lock_irqsave(&rstc->lock, flags);
+		reg = readl(rstc->membase + offset);
+		/* set reset bit */
+		reg |= (1 << reset);
+		reg |= (1 << (reset + 0x10)); // note: write enable
+		writel(reg, rstc->membase + offset);
+		spin_unlock_irqrestore(&rstc->lock, flags);
+	} else {
+		spin_lock_irqsave(&rstc->lock, flags);
+		reg = readl(rstc->membase + offset);
+		/* set reset bit */
+		if ((offset == 0x20) || (offset == 0x24) || (offset == 0x80) ||
+		    (offset == 0x64)) {
+			reg |= (0 << reset); //special，复位：reset=0
+		} else if ((offset == 0x4) || (offset == 0xc)) {
+			reg |= (1 << reset);
+			reg |= (1 << (reset + 0x10)); //note: write enable
+		} else {
+			reg |= (1 << reset);
+		}
+		writel(reg, rstc->membase + offset);
+		spin_unlock_irqrestore(&rstc->lock, flags);
+	}
+	return 0;
+}
+
+static int k230_reset_deassert(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	struct k230_reset_controller *rstc = to_k230_reset_controller(rcdev);
+	unsigned long flags;
+	u32 offset = (id & K230_RESET_REG_OFFSET_MASK) >>
+		     K230_RESET_REG_OFFSET_SHIFT;
+	u32 type = (id & K230_RESET_TYPE_MASK) >> K230_RESET_TYPE_SHIFT;
+	u32 done = (id & K230_RESET_DONE_BIT_MASK) >> K230_RESET_DONE_BIT_SHIFT;
+	u32 reset = (id & K230_RESET_ASSERT_BIT_MASK) >>
+		    K230_RESET_ASSERT_BIT_SHIFT;
+	u32 reg;
+
+	// if(type == K230_RESET_TYPE_HW_AUTO_DONE) {
+	//     pr_err("hardware auto done reset DOESNOT support reset assert!");
+	// } else {
+	//     spin_lock_irqsave(&rstc->lock, flags);
+	//     reg = readl(rstc->membase+offset);
+	//     /* clear reset bit */
+	//     reg &= ~(1 << reset);
+	//     writel(reg, rstc->membase+offset);
+	//     if(type == K230_RESET_TYPE_CPU) {
+	//         /* check bit done */
+	//         while(1) {
+	//             reg = readl(rstc->membase+offset);
+	//             if(reg & (1 << done)) {
+	//                 /* clear done and break */
+	//                 writel(reg, rstc->membase+offset);
+	//                 break;
+	//             }
+	//         }
+	//     }
+	//     spin_unlock_irqrestore(&rstc->lock, flags);
+	if (type == K230_RESET_TYPE_HW_AUTO_DONE) {
+		pr_err("hardware auto done reset DOESNOT support reset assert!");
+	} else if (type == K230_RESET_TYPE_CPU) {
+		spin_lock_irqsave(&rstc->lock, flags);
+		reg = readl(rstc->membase + offset);
+		/* clear reset bit */
+		if (offset == 0xc) {
+			reg &= ~(1 << reset);
+			reg &= (1 << (reset + 0x10)); // note: write enable
+			writel(reg, rstc->membase + offset);
+		}
+
+		/* wait done bit set */
+		while (1) {
+			reg = readl(rstc->membase + offset);
+			if (reg & (1 << done)) {
+				/* clear done and break */
+				writel(reg, rstc->membase + offset);
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&rstc->lock, flags);
+	} else {
+		spin_lock_irqsave(&rstc->lock, flags);
+		reg = readl(rstc->membase + offset);
+		/* clear reset bit */
+		if ((offset != 0x4) &&
+		    (offset != 0xc)) { //special，0x4, 0xc寄存器是自动清零
+			if (offset == 0xa8) {
+				reg &= ~(1 << reset);
+				writel(reg, rstc->membase + offset);
+			} else {
+				reg &= ~(0 << reset);
+				writel(reg, rstc->membase + offset);
+			}
+		}
+		spin_unlock_irqrestore(&rstc->lock, flags);
+	}
+	return 0;
+}
+
+static const struct reset_control_ops k230_reset_ops = {
+	.reset = k230_reset,
+	.assert = k230_reset_assert,
+	.deassert = k230_reset_deassert,
+};
+static int k230_restart(struct notifier_block *this, unsigned long mode,
+			void *cmd)
+{
+#define SYSCTL_BOOT_BASE_ADDR 0x91102000U
+#define CPU0_RST_CTL 0x60
+
+	void __iomem *MMAP_ADDR =
+		ioremap(SYSCTL_BOOT_BASE_ADDR + CPU0_RST_CTL, 4);
+
+	writel(((1 << 0) | (1 << 16)), MMAP_ADDR);
+
+	while (1)
+		;
+
+	return 0;
+}
+
+static int k230_restart_register(void)
+{
+	static struct notifier_block restart_handler;
+
+	restart_handler.notifier_call = k230_restart;
+	restart_handler.priority = 128;
+
+	return register_restart_handler(&restart_handler);
+}
+
+static int k230_reset_probe(struct platform_device *pdev)
+{
+	struct k230_reset_controller *rstc;
+	struct resource *res;
+
+	k230_restart_register();
+
+	rstc = devm_kmalloc(&pdev->dev, sizeof(*rstc), GFP_KERNEL);
+	if (!rstc)
+		return -1;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	rstc->membase =
+		devm_ioremap(&pdev->dev, res->start, resource_size(res));
+	if (!rstc->membase) {
+		pr_err("k230_reset_init devm_ioremap error!");
+		return -1;
+	}
+#ifdef K230_RESET_DEBUG
+	pr_info("[K230_RESET]:sysctl reset phy addr 0x%08x", (int)res->start);
+#endif
+
+	spin_lock_init(&rstc->lock);
+	rstc->rst.owner = THIS_MODULE;
+	rstc->rst.ops = &k230_reset_ops;
+	rstc->rst.of_node = pdev->dev.of_node;
+	rstc->rst.of_reset_n_cells = 4;
+	rstc->rst.of_xlate = k230_reset_of_xlate;
+	if (reset_controller_register(&rstc->rst) == 0) {
+#ifdef K230_RESET_DEBUG
+		pr_info("[K230_RESET]: ok!");
+#endif
+	} else {
+		pr_info("[K230_RESET]: error!");
+	}
+
+	return 0;
+}
+
+void k230_reset_exit(struct k230_reset_controller *rstc)
+{
+	reset_controller_unregister(&rstc->rst);
+}
+
+static const struct of_device_id k230_reset_match[] = {
+	{
+		.compatible = "canaan,k230-sysctl-reset",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, k230_reset_match);
+
+static struct platform_driver
+	k230_reset_driver = { .probe = k230_reset_probe,
+			      .driver = {
+				      .name = "k230-sysctl-reset",
+				      .of_match_table = k230_reset_match,
+			      } };
+
+builtin_platform_driver(k230_reset_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:k230-sysctl-reset");
+MODULE_DESCRIPTION("Canaan K230 Reset Driver");
-- 
2.25.1

